- SQL Server Reporting Services (SSRS): is a reporting software that allows you to produce formatted reports with tables in the form of data, graph, images, and charts. These reports are hosted on a server that can be executed any time using parameters defined by the users. It is part of Microsoft SQL Server Services suite.
You first create the report itself (.rdl) by desiging it and provide the data source (db connection) and the data set (query or stored procedure) and then configure the subscription, all of this after configuring the SSRS reporting server and configuring the mail settings, from the SQL Server you can connect to thr Reporting Server and click server properities to get the URL and paste this URL in VS > project properities > Target ServerURL and then right click on project and choose deploy (dont forget to Run As Admin), to view the report open the Web Portal url in IE with Run As Admin 
- Integer data type reserve a 4 bytes in memory.
- Any recursive function should have a condition to end the recursion.
- In mathematical expressions, Multiplication\devision has a priority before addition\substraction.
- Big O is simply used to describe the performance of an algorithm, which describe the Time & Space complexity.
- Big O: is how much the runtime of this code increases as the size of the input increases
	- Constant O(1): the time doesnt increase by incresing input size.
	- Linear O(n): the time consumed increase as much as the input increase.
	- Quadratic O(n^2):
- How to calculate the Big O: (ex: cn + dn^2 + e)
	- choose the fastest growing term > dn^2
	- Remove the coeffecient > n^2 > Quadratic
	- so in general, you can check every line of code, how this line can be affected according to the input size.
- We have to understand Data Structures well because the data structure object you decide to use will affect your code performance
- Code performance is always to Save Time and Save Space, so you need to decide which factor is more important so if you are developing a mobile app then saving space is much important and so on.
- Data Structures:
	- Array is a collection of items that should be with a fixed length, and we can't add more numbers to exceed the length BECAUSE, in memory we book a specific number of bytes to insert array values sequentialy so that we may have other variables book the next slots of memory so we can't insert new values beside the old values in memory, because to insert array values we need a bunch of consective bytes.
	and what about the List (the dynamic array) its working like everytime you add a new value it defines a new array with the length of old + new values and so on
      Time needed to access an element in array is O(1) constant time because the array elements are stored in a contigious block of memory
	- Class is a blue print that you create objects from, so that you define props in class and assign these props values while instantiating it (creating an object), and also you need to make this assignment in class constructor for the mandatory props so that you will defintly pass it when you create object.
	- Tree:
	- Binary Search: go to the middle point of array and check if the target is greater than the middle then move to the right and repeat:
	    public static int BinarySearch(int[] source, int target)
        {
            int left = 0, middle = 0;
            int right = source.Length - 1;
            while (left < right)
            {
                middle = (left + right) / 2;
                if (source[middle] == target)
                    return middle;
                else if (target < source[middle])
                    right = middle - 1;
                else if (target > source[middle])
                    left = middle + 1;
            }
            return middle;
        }
	- Linear Search:
    - Quick Sort: its a devide and conquer algorithm where every element find its sorted position that follow the below steps:
        - partition list into 2 sub-arrays by selecting the pivot element:
            - consider pivot as the first element.
            - loop through elements if found element < pivot then swap it.
            - swap the pivot with the last swaped location location (move pivot to its sorted location).
            - return the last swaped location as the new pivot
        - repeat the quickSort again from left to pivot
        - repeat the quickSort again from pivot to right
        # region Quick Sort
        public static int[] QuickSort(int[] given_array, int start, int end)
        {
            if (start < end)
            {
                int pivotIndex = QuickSortPartition(given_array, start, end);
                QuickSort(given_array, start, pivotIndex);
                QuickSort(given_array, pivotIndex + 1, end);
            }
            return given_array;
        }

        public static int QuickSortPartition(int[] given_array, int left, int right)
        {
            int pivot = given_array[left];
            int swapIndex = left;
            for (int i = left + 1; i < right; i++)
            {
                if (given_array[i] < pivot)
                {
                    swapIndex++;
                    SwapArray(ref given_array, i, swapIndex); // sort these 2 elements
                }
            }
            SwapArray(ref given_array, left, swapIndex); // move pivot to its sorted location
            return swapIndex;
        }

        public static void SwapArray(ref int[] given_array, int firstIndex, int secondIndex)
        {
            int temp = given_array[firstIndex];
            given_array[firstIndex] = given_array[secondIndex];
            given_array[secondIndex] = temp;
        }
        #endregion

    - To deside what kind of data structures you should use, you need to consider these factors: size of data, is the data fixed or dynamic, how much frequent operations done (cost of operations), 
    - Dictionary (HashMap in Java): is a collection of KeyValue pairs implemented by HashTable, it talk O(1) time to find an element
    - Hash Table: a collection of key-and-value pairs that are organized based on the hash code of the key, which uses the Hash Function to hash the key
        a methodology for storing array elements in indexes related to its values (do some equations to calculate the element index from its value)
    - List: is a collection of objects with the same data type, it has no good memory utilization since it creates a new memory locations for the whole elements every time you add or remove elements.
    - Linked List: every node has 2 locations in memory, one for the node value and another for a pointer to the next node, 
        to access element in the linked list, it takes O(n), 
        Apart from storing linked list elements into memory, we need also another memory slot to save the address of the first element in the linked list (a pointer to head) which called the identity of the linked list.
        what is distinguish linked list than array is that if you want to add\remove an element to\from the linked list you will just need to reference the next element address in its value and also set the new element's address as reference in the previous element, but in array you will need to shift the index increase\decrease for all elements after\before the element you want to delete\add.
        So in general linked list need extra memroy for every element to store a reference to the next element, but array need only one slot of memory for every element.
    - Doubly Linked List: is a normal linked list but each element has 2 references, one for the next node and another for the previous node.
    - Most common examples of using Stack data structure is: Function Calls so the last function enter stack is the first one to finish, Also one more example is the Undo function to reverse changes one by one most recently.
    - Stack and Queue can be implemented using Array or LinkedList
    - Tree data structure is used to store a hierarchical data