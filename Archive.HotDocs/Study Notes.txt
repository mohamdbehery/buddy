- Assembly > Namespace > Class > Props & Methods
- AssemblyInfo.cs is containing all data related to your assembly like Title, Desc, CopyRight, TradeMark and Version
- Reserved Bytes for data types: bool: 1, int: 4, string: 4, float: 4, double: 8, decimal: 16
- By default the C# compiler treat number as double so to prevent this we can add a suffix (f) to the number like this float number = 12.45f;
- If you have to inherit from BaseClass and interface you should put the BaseClass first like this public class ChildClass : BaseClass, IClass (not the oposite)
- If you want to segregate two interfaces without repeat members you can do this 
	public interface IProduct{
		void A();
		void B();
	}
	public interface IClothes{
		void C();
	}

	public class Dress: IClothes{

	}

- Abstract class doesn't allow us to instantiate it but inherit
- Abstract class > what if you have 2 different class with the same target like SQLDataAccess and OracleDataAccess, then the optimum way to design it like below:
	like this we have implemented the common methons only one time and give the ability to the child classes to override the methods that they have a difference in implementation.
	Also, if you want to give the ability (as optional) to the child classes to override the LoadConnectionString method just put (virtual) keywaord in its signature

	public abstract class DataAccess{
		public void LoadConnectionString(){
			....
		}
		public abstract void LoadData();
		public abstract void SaveData();
	}

	public class SQLDataAccess: DataAccess{
		public override void LoadData(){			
		}
		public override void SaveData(){			
		}
	}

	public class OracleDataAccess: DataAccess{
		public override void LoadData(){			
		}
		public override void SaveData(){			
		}
	}

- If you have more than 1 constructor and you want to call one from another (like that the base constructor will run first):
	public class Customer{
		public int Id;
		public string Name;
		public Order _order;

		public Customer(){
			this.Id = 1;
		}

		public Customer(string name): this(){
			this.Name = name;
			this._order = new Order{
				Id = this.Id,
				Name = this.Name
			};
		}
	}

- When to use Struct
- Simple definition for Interface: for example the company needs a Developer with a specific skills Not need (Mohamed) so in any time the company may replace Mohamed with any other Developer that has these skills so the Interface here is the Developer Skills as a Contract.
- Interface objects should not have access modifiers in signature, just return type, name and parameters
- the class that implement interface should have the implemented methods as public
- static class should not have a constructor because it cannot be instantiated
- Override keyword is used in either implementing a abstract method in the base class or overriding a method in base class that has virtual in its signature
- Overloading can be acheived by difference in return type as long as we have a difference in parameters
- No difference between Person person1 = new Person{ Name = ""}; AND Person person1 = new Person(){ Name = ""};
- CTE can be refertenced only once, right after defining it, so if you want to use a permenant table consider using temp table or table variable
- Delegates: is and agreement\contract between publisher and subscriber, so simply if you want to do some generic functionality right after finishing executing some task then implement a Delegate Evenet for example:
	* so the idea here is that you have the ability to add any other functionality to be executed after finishing video decoder,
	public class MyApp{
		public void MyMethod(){
			VideoDecoder decoder = new VideoDecoder(); //publisher
			Notifier notifier = new Notifier(); //subscriber

			// let the notifier subscribe to the VideDecoded event
			decoder.VideoDecoded += notifier.OnVideoDecoded;
			decoder.Decode();
		}

		public class VideoDecoder{ // publisher
			public event EventHandler VideoDecoded;

			public void Decode(){
				// decoding...
			}
			protected void OnVideoDecoded()
			{
				if (VideoDecoded != null)
					VideoDecoded(this, EventArgs.Empty);
			}			
		}

		public class Notifier{ // subscriber			
			public void OnVideoDecoded()
			{
				SendMail();
			}
			
			public void SendMail(){
				// sending mail...
			}
		}
	}

- Git is a distributed version control system but TFS is a centralized VCS, so in GIT, every one has a local copy of the source code and also support branching.
- Git Command (git config) has a 3 levels of configuration: (git config --global) which use the global config file to be applied on all users that use this computer, (git config --system) which use the system config file to be applied on all repositories for current user and (git config --local) use use the repository config file to be applied on a particular repository
- Every Git Commit contains a complete snapshot of the respo.
- Use command (git status) to show the status of your changes, or (git status -s) for short status
- Git > local changes > stagging are (local) the stagging are is called (index) > push to remote server
- If you want to review the stagged files before commit, use this command (git diff --staged)
- To view history of repo activities, use (git log)
- The branch is a new commit that pointing to some particular parent (commit in another branch)
- The merge is nothing but a new commit that pointing to 2 parents (2 commits in 2 branches)
- (git rebase) is simply making the branch pointing to some particular parent branch(commit)
- C# object indexer: An indexer is a special type of property that allows a class or a structure to be accessed like an array for its internal collection. C# allows us to define custom indexers, generic indexers, and also overload indexers, An indexer can be defined the same way as property with this keyword and square brackets []
	class StringDataStore
	{
		private string[] strArr = new string[10]; // internal data storage

		public string this[int index]
		{
			get => strArr[index];

			set => strArr[index] = value;
		}
	}

- Generics: reduce code redunduncy and increase performance, instead of using objects that make us do boxing and unboxing, we use generics to pass the type 
	public calss GenericClass<T> where T : IComparable{
		public T Add(T input1, T input2){
			
		}
	}

	So, here we have applied generics constraint for T to accept any type that implement IComparable, also we can add more constraints (separated by comma)
- Repository Pattern: is a mediate (abstraction) layer between the domain (business) layer and data mapping layer (ORM) so that you hide how the data is eventually stored or retrieved to and from the DB, so the main purpose here is to make your achitecture a loosly decopled of ORM
- One of the benefits of UnitOfWork is that you can savechanges of more than one entity at the same time (like a transaction)

- SDLC:
	- Project preparation discuss resource and the skills needed, apply tranings or self-study if needed.
	- Having a standup everyday for 30 minutes
	- Having a grooming meeting (to be recorded) between all the project teams including the business team to set priorities of backlog tickes and clarify and estimate tickets
	- Integrate Github with Jira to show the created branch, merge or pull request for each ticket
	- Integrate Jira with WiKI (which contains all project docs and also the grooming recordings)
	- Retrospective meetings: (every 2 weeeks) are a great opportunity for people to come together to talk about what went well, what didn’t go so well, and what will be changed for the next project.

	Workflow:
	- Once you have a ticket, create a feature branch (feature/AS-1234) and start develop
	- Once you finish > create Pull Request from your feature branch to develop branch
	- Once merged to develop, the jenkins job for build and deploy will be auto-triggered to deploy to the QA environment
	- Once we have the QA SignOff, merge between develop and release
	- Once the merge done, it will trigger the jenkins job responsible to deploy to UAT
	- Once deployed to UAT, the business team should validate the ticket
	- Once we have the business team SignOff for all sprint tickets that will be included in the release, we run the jenkins job to deploy to prod from release branch
	- Once the prod deployment done, the QA should run the regression test
	- Once we have the prod SignOff, then merge from release to master and develop branches

