
- 
- CTE can be refertenced only once, right after defining it, so if you want to use a permenant table consider using temp table or table variable
- Delegates: is and agreement\contract between publisher and subscriber, so simply if you want to do some generic functionality right after finishing executing some task then implement a Delegate Evenet for example:
	* so the idea here is that you have the ability to add any other functionality to be executed after finishing video decoder,
	public class MyApp{
		public void MyMethod(){
			VideoDecoder decoder = new VideoDecoder(); //publisher
			Notifier notifier = new Notifier(); //subscriber

			// let the notifier subscribe to the VideDecoded event
			decoder.VideoDecoded += notifier.OnVideoDecoded;
			decoder.Decode();
		}

		public class VideoDecoder{ // publisher
			public event EventHandler VideoDecoded;

			public void Decode(){
				// decoding...
			}
			protected void OnVideoDecoded()
			{
				if (VideoDecoded != null)
					VideoDecoded(this, EventArgs.Empty);
			}			
		}

		public class Notifier{ // subscriber			
			public void OnVideoDecoded()
			{
				SendMail();
			}
			
			public void SendMail(){
				// sending mail...
			}
		}
	}

- Git is a distributed version control system but TFS is a centralized VCS, so in GIT, every one has a local copy of the source code and also support branching.
- Git Command (git config) has a 3 levels of configuration: (git config --global) which use the global config file to be applied on all users that use this computer, (git config --system) which use the system config file to be applied on all repositories for current user and (git config --local) use use the repository config file to be applied on a particular repository
- Every Git Commit contains a complete snapshot of the respo.
- Use command (git status) to show the status of your changes, or (git status -s) for short status
- Git > local changes > stagging are (local) the stagging are is called (index) > push to remote server
- If you want to review the stagged files before commit, use this command (git diff --staged)
- To view history of repo activities, use (git log)
- The branch is a new commit that pointing to some particular parent (commit in another branch)
- The merge is nothing but a new commit that pointing to 2 parents (2 commits in 2 branches)
- (git rebase) is simply making the branch pointing to some particular parent branch(commit)
- C# object indexer: An indexer is a special type of property that allows a class or a structure to be accessed like an array for its internal collection. C# allows us to define custom indexers, generic indexers, and also overload indexers, An indexer can be defined the same way as property with this keyword and square brackets []
	class StringDataStore
	{
		private string[] strArr = new string[10]; // internal data storage

		public string this[int index]
		{
			get => strArr[index];

			set => strArr[index] = value;
		}
	}

- Generics: reduce code redunduncy and increase performance, instead of using objects that make us do boxing and unboxing, we use generics to pass the type 
	public calss GenericClass<T> where T : IComparable{
		public T Add(T input1, T input2){
			
		}
	}

	So, here we have applied generics constraint for T to accept any type that implement IComparable, also we can add more constraints (separated by comma)
- Repository Pattern: is a mediate (abstraction) layer between the domain (business) layer and data mapping layer (ORM) so that you hide how the data is eventually stored or retrieved to and from the DB, so the main purpose here is to make your achitecture a loosly decopled of ORM
- One of the benefits of UnitOfWork is that you can savechanges of more than one entity at the same time (like a transaction), creating a single database context class shared by all repositories.

- SDLC:
	- Project preparation discuss resource and the skills needed, apply tranings or self-study if needed.
	- Having a standup everyday for 30 minutes
	- Having a grooming meeting (to be recorded) between all the project teams including the business team to set priorities of backlog tickes and clarify and estimate tickets
	- Integrate Github with Jira to show the created branch, merge or pull request for each ticket
	- Integrate Jira with WiKI (which contains all project docs and also the grooming recordings)
	- Retrospective meetings: (every 2 weeeks) are a great opportunity for people to come together to talk about what went well, what didn’t go so well, and what will be changed for the next project.

	Workflow:
	- Once you have a ticket, create a feature branch (feature/AS-1234) and start develop
	- Once you finish > create Pull Request from your feature branch to develop branch
	- Once merged to develop, the jenkins job for build and deploy will be auto-triggered to deploy to the QA environment
	- Once we have the QA SignOff, merge between develop and release
	- Once the merge done, it will trigger the jenkins job responsible to deploy to UAT
	- Once deployed to UAT, the business team should validate the ticket
	- Once we have the business team SignOff for all sprint tickets that will be included in the release, we run the jenkins job to deploy to prod from release branch
	- Once the prod deployment done, the QA should run the regression test
	- Once we have the prod SignOff, then merge from release to master and develop branches

