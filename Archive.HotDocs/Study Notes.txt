- SQL Server Reporting Services (SSRS): is a reporting software that allows you to produce formatted reports with tables in the form of data, graph, images, and charts. These reports are hosted on a server that can be executed any time using parameters defined by the users. It is part of Microsoft SQL Server Services suite.
You first create the report itself (.rdl) by desiging it and provide the data source (db connection) and the data set (query or stored procedure) and then configure the subscription, all of this after configuring the SSRS reporting server and configuring the mail settings, from the SQL Server you can connect to thr Reporting Server and click server properities to get the URL and paste this URL in VS > project properities > Target ServerURL and then right click on project and choose deploy (dont forget to Run As Admin), to view the report open the Web Portal url in IE with Run As Admin 
- Integer data type reserve a 4 bytes in memory.
- Keep your code simple, and don't do over-engineering.
- When running code, every function reserve a memory location in the stack so any varaible inside this function should be stored in this memory location, so this is how the function scope variables are no longer available as soon as the compiler finished the function execution and go outside it because at that time it should be deleted from memory.
- The memory of Stack got deallocated as soon as the function ended but in Heap its still as long as the application is running.
- When any application start, the memory manager auto reserve a specific size in Stack for it, but the Heap size can vary during the runtime of the application (Heap is a free pool of memory or dynamic memory), so the Stack memory slots auto-cleared as soon as the function finished calling, but the heap memory cleaning is managed by the garbage collector.
- Memory Leak can happen when we inproperly use Heap so there is a lot of unused or unreferenced blocks in the Heap, but for Stack you may have StackOverFlow error
- You allocate momory in Heap whenever you use (new) keyword.
- Memory has different parts: Stack, Heap and Global, Global is used to save the global objects (not function scope)
- Any recursive function should have a condition to end the recursion.
- In mathematical expressions, Multiplication\devision has a priority before addition\substraction.
- Big O is simply used to describe the performance of an algorithm, which describe the Time & Space complexity.
- Big O: is how much the runtime of this code increases as the size of the input increases
	- Constant O(1): the time doesnt increase by incresing input size.
	- Linear O(n): the time consumed increase as much as the input increase.
	- Quadratic O(n^2):
- How to calculate the Big O: (ex: cn + dn^2 + e)
	- choose the fastest growing term > dn^2
	- Remove the coeffecient > n^2 > Quadratic
	- so in general, you can check every line of code, how this line can be affected according to the input size.
- We have to understand Data Structures well because the data structure object you decide to use will affect your code performance
- Code performance is always to Save Time and Save Space, so you need to decide which factor is more important so if you are developing a mobile app then saving space is much important and so on.
- Data Structures:
	- Array is a collection of items that should be with a fixed length, and we can't add more numbers to exceed the length BECAUSE, in memory we book a specific number of bytes to insert array values sequentialy so that we may have other variables book the next slots of memory so we can't insert new values beside the old values in memory, because to insert array values we need a bunch of consective bytes.
	and what about the List (the dynamic array) its working like everytime you add a new value it defines a new array with the length of old + new values and so on
      Time needed to access an element in array is O(1) constant time because the array elements are stored in a contigious block of memory
	- Class is a blue print that you create objects from, so that you define props in class and assign these props values while instantiating it (creating an object), and also you need to make this assignment in class constructor for the mandatory props so that you will defintly pass it when you create object.
    - To deside what kind of data structures you should use, you need to consider these factors: size of data, is the data fixed or dynamic, how much frequent operations done (cost of operations), 
    - Dictionary (HashMap in Java): is a collection of KeyValue pairs implemented by HashTable, it talk O(1) time to find an element
    - Hash Table: a collection of key-and-value pairs that are organized based on the hash code of the key, which uses the Hash Function to hash the key
        a methodology for storing array elements in indexes related to its values (do some equations to calculate the element index from its value)
    - List: is a collection of objects with the same data type, it has no good memory utilization since it creates a new memory locations for the whole elements every time you add or remove elements.
    - Linked List: every node has 2 locations in memory, one for the node value and another for a pointer to the next node, 
        to access element in the linked list, it takes O(n), 
        Apart from storing linked list elements into memory, we need also another memory slot to save the address of the first element in the linked list (a pointer to head) which called the identity of the linked list.
        what is distinguish linked list than array is that if you want to add\remove an element to\from the linked list you will just need to reference the next element address in its value and also set the new element's address as reference in the previous element, but in array you will need to shift the index increase\decrease for all elements after\before the element you want to delete\add.
        So in general linked list need extra memroy for every element to store a reference to the next element, but array need only one slot of memory for every element.
    - Doubly Linked List: is a normal linked list but each element has 2 references, one for the next node and another for the previous node.
    - Most common examples of using Stack data structure is: Function Calls so the last function enter stack is the first one to finish, Also one more example is the Undo function to reverse changes one by one most recently.
    - Stack and Queue can be implemented using Array or LinkedList
    - Tree data structure is used to store a hierarchical data, where each node has 1 or more childs
    - Binary Tree: is a normal tree where each node has only 2 childs
    - Binary Search Tree (BST): is a binary tree where for every node, all nodes on its right side has value greated than its value and all nodes to the left has value less than its value,, exactly like the Binary Search in general we should have the array sorted so this is the same we assume the tree as a binary search tree if each node in the left is less than its sibling in the right.
        so finding an element in a binary search tree is just costing O(log n).
        so if you want to find the minimum value in a BST, you just go to the left as much as it exists (the last element), and the miximum is the last element in the right.
    - Hight of a node: is the number of edges in the longest path from the node to the leaf node.
    - Graph: is a Tree but with no leaves, where the number of nodes equal the number of edges.
    - Directed Graph: where the edges between nodes are in one direction, but the Undirected Graph, the edges have 2 directions.
        social networks are a good example for the UnDirected Graph where each node has 2 directions to each other.
    - Keep in mind that, Recursive functions is used in most of Data Structures implementation.
    - Data Structures has 2 types: Linear Data Structures like Array, Stack, Queue, Linked List and Hierachical Data Structures like Tree and Graphs.
    - Task implementation steps:
        - Defining the problem clearly
        - Breaking the problem down into small, simple parts
        - Define the solution for each part of the problem
        - Implementing the solution
        - Making it efficient (eventually)

- Algorithms (most famous) algorithms are just ways to do things, mostly for searching and sorting:
    - Linear Search: It sequentially checks each element of the list until a match is found or the whole list has been searched, it cost O(n)
	- Binary Search: assuming that the elements are sorted, go to the middle point of array and check if the target is greater than the middle then move to the right and repeat:
	    public static int BinarySearch(int[] source, int target)
        {
            int left = 0, middle = 0;
            int right = source.Length - 1;
            while (left < right)
            {
                middle = (left + right) / 2;
                if (source[middle] == target)
                    return middle;
                else if (target < source[middle])
                    right = middle - 1;
                else if (target > source[middle])
                    left = middle + 1;
            }
            return middle;
        }

    - DFS Depth First Search: is used to find an element in a graph\tree by visiting all graph nodes and exploring all connected nodes as following, it cost O(n): 
        1. visit any node as a start node, and push to STACK.
        2. loop through the stack:
            - for current node, explore one of its connected node and check if its not exist in the stack (not visited) then push to the stack otherwise pop from the stack untill you reach this visited node and check the other connected node for this visited node. 
            - repeat the process until the stack become empty

    - BFS Breadth First Search: is used to find an element in a graph\tree by visiting all graph nodes and exploring all connected nodes as following, it cost O(n):
        1. visit any node as a start node, and push to QUEUE.
        2. loop through the queue
            - for current node, explore all connected nodes by enqueueing them into queue and delete this node
            - repeat untill the queue is empty

    - Quick Sort: its a devide and conquer algorithm where every element find its sorted position that follow the below steps:
        - partition list into 2 sub-arrays by selecting the pivot element:
            - consider pivot as the first element.
            - loop through elements if found element < pivot then swap it, until the left and right pointers replaced
            - swap the pivot with the last swaped location location (move pivot to its sorted location).
            - return the last swaped location as the new pivot
        - repeat the quickSort again from left to pivot
        - repeat the quickSort again from pivot to right
        # region Quick Sort
        public static int[] QuickSort(int[] given_array, int start, int end)
        {
            if (start < end)
            {
                int pivotIndex = QuickSortPartition(given_array, start, end);
                QuickSort(given_array, start, pivotIndex);
                QuickSort(given_array, pivotIndex + 1, end);
            }
            return given_array;
        }

        public static int QuickSortPartition(int[] given_array, int left, int right)
        {
            int pivot = given_array[left];
            int swapIndex = left;
            for (int i = left + 1; i < right; i++)
            {
                if (given_array[i] < pivot)
                {
                    swapIndex++;
                    SwapArray(ref given_array, i, swapIndex); // sort these 2 elements
                }
            }
            SwapArray(ref given_array, left, swapIndex); // move pivot to its sorted location
            return swapIndex;
        }

        public static void SwapArray(ref int[] given_array, int firstIndex, int secondIndex)
        {
            int temp = given_array[firstIndex];
            given_array[firstIndex] = given_array[secondIndex];
            given_array[secondIndex] = temp;
        }
        #endregion 
    
    - Merge Sort: based on the Devide and Conquer approach, we devide the list into sub lists until we have a very small lists (1 element) then merge it up (sorted) one by one until merge it all again but in a sorted order, it cost O(n log n)
        #region Merge Sort
        public static void Merge(int[] arr, int left, int middle, int right)
        {
            int leftArrayLength = middle - left + 1;
            int rightArrayLength = right - middle;

            // Devide array 
            int[] leftArray = new int[leftArrayLength], rightArray = new int[rightArrayLength];
            for (int x = 0; x < leftArrayLength; x++)
                leftArray[x] = arr[left + x];
            for (int y = 0; y < rightArrayLength; y++)
                rightArray[y] = arr[middle + 1 + y];

            // Maintain current index of sub-arrays and main array
            int i, j, k;
            i = 0;
            j = 0;
            k = left;

            // Until we reach either end of either L or M, pick larger among
            // elements L and M and place them in the correct position at A[p..r]
            while (i < leftArrayLength && j < rightArrayLength)
            {
                if (leftArray[i] <= rightArray[j])
                {
                    arr[k] = leftArray[i];
                    i++;
                }
                else
                {
                    arr[k] = rightArray[j];
                    j++;
                }
                k++;
            }

            // When we run out of elements in either L or M,
            // pick up the remaining elements and put in A[p..r]
            while (i < leftArrayLength)
            {
                arr[k] = leftArray[i];
                i++;
                k++;
            }

            while (j < rightArrayLength)
            {
                arr[k] = rightArray[j];
                j++;
                k++;
            }
        }

        public static int[] MergeSort(int[] given_array, int left, int right)
        {
            if (left >= right)
            {
                return given_array;
            }
            int middle = left + (right - left) / 2;
            MergeSort(given_array, left, middle);
            MergeSort(given_array, middle + 1, right);
            Merge(given_array, left, middle, right); // merge two subarrays L and M into arr

            return given_array;
        }
        #endregion

    - Bubble Sort: loop twice in list elements, so it cost O(n^2)
        - loop to compare each element with the next one, if the next one is greater, then swap
        - execlude the last element from the list because it will be already sorted
        - repeat first step
        - exclude the last 2 elements, because it will be sorted
        - repeat this until either excluding all elements or found an iteration without any replacement
        #region Bubble Sort
        public static int[] BubbleSort(int[] given_array)
        {
            int temp = 0;
            bool alreadySorted = true;

            for (int i = 0; i < given_array.Length; i++)
            {
                alreadySorted = true;
                for (int j = 0; j < given_array.Length - 1; j++)
                {
                    if (given_array[j] > given_array[j + 1])
                    {
                        temp = given_array[j + 1];
                        given_array[j + 1] = given_array[j];
                        given_array[j] = temp;
                        alreadySorted = false;
                    }
                }
                if (alreadySorted) { break; /*early escape*/ }
            }
            return given_array;
        }
        #endregion

    - Selection Sort: simply is foreach element we select the elment that is less than it and swap them, so it cost O(n^2)
        #region Selection Sort
        public static int[] SelectionSort(int[] given_array)
        {
            int arrayLength = given_array.Length;

            // One by one move boundary of unsorted subarray
            for (int i = 0; i < arrayLength - 1; i++)
            {
                // Find the minimum element in unsorted array
                int min_idx = i;
                for (int j = i + 1; j < arrayLength; j++)
                    if (given_array[j] < given_array[min_idx])
                        min_idx = j;

                // Swap the found minimum element with the first element
                int temp = given_array[min_idx];
                given_array[min_idx] = given_array[i];
                given_array[i] = temp;
            }
            return given_array;
        }
        #endregion

    - Insertion Sort: is simply foreach element we insert it in its sorted position, so it cost O(n^2):
        #region Insertion Sort
        public static int[] InsertionSort(int[] given_array)
        {
            int n = given_array.Length;
            for (int i = 1; i < n; ++i)
            {
                int element = given_array[i];
                int j = i - 1;

                // Move elements of arr[0..i-1], that are greater than key, to one position ahead of their current position
                while (j >= 0 && given_array[j] > element)
                {
                    given_array[j + 1] = given_array[j];
                    j = j - 1;
                }
                given_array[j + 1] = element;
            }
            return given_array;
        }
        #endregion 

    - Prime number: is the numbers that has zero reminder % in only 1 and itself (accept devide by 1 and itself)

    - Difference between Hashing and Encryption: is that hashing converts the data to message hash that identify the message so that when the receiver recieves your message he will hash the message and compared the generated hash with the one sent in the message, and it should be the same, so Hashing is one-way, while encryption uses a key to convert the message to transmit into an unrecognizable format, two-way encryption.
        one of the most practical example for Hashing is when you want to check if some data changed in a big combination of data in database, you can simply prepare a selec qurery for it and hash the result and compare the hash with the last hashed value so if they are not the same then one or more columns\tables data changed.
